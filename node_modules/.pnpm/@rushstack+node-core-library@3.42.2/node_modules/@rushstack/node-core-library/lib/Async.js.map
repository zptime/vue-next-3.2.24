{"version":3,"file":"Async.js","sourceRoot":"","sources":["../src/Async.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Options for controlling the parallelism of asynchronous operations.\r\n *\r\n * @remarks\r\n * Used with {@link Async.mapAsync} and {@link Async.forEachAsync}.\r\n *\r\n * @beta\r\n */\r\nexport interface IAsyncParallelismOptions {\r\n  /**\r\n   * Optionally used with the  {@link Async.mapAsync} and {@link Async.forEachAsync}\r\n   * to limit the maximum number of concurrent promises to the specified number.\r\n   */\r\n  concurrency?: number;\r\n}\r\n\r\n/**\r\n * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.\r\n *\r\n * @beta\r\n */\r\nexport class Async {\r\n  /**\r\n   * Given an input array and a `callback` function, invoke the callback to start a\r\n   * promise for each element in the array.  Returns an array containing the results.\r\n   *\r\n   * @remarks\r\n   * This API is similar to the system `Array#map`, except that the loop is asynchronous,\r\n   * and the maximum number of concurrent promises can be throttled\r\n   * using {@link IAsyncParallelismOptions.concurrency}.\r\n   *\r\n   * If `callback` throws a synchronous exception, or if it returns a promise that rejects,\r\n   * then the loop stops immediately.  Any remaining array items will be skipped, and\r\n   * overall operation will reject with the first error that was encountered.\r\n   *\r\n   * @param iterable - the array of inputs for the callback function\r\n   * @param callback - a function that starts an asynchronous promise for an element\r\n   *   from the array\r\n   * @param options - options for customizing the control flow\r\n   * @returns an array containing the result for each callback, in the same order\r\n   *   as the original input `array`\r\n   */\r\n  public static async mapAsync<TEntry, TRetVal>(\r\n    iterable: Iterable<TEntry> | AsyncIterable<TEntry>,\r\n    callback: (entry: TEntry, arrayIndex: number) => Promise<TRetVal>,\r\n    options?: IAsyncParallelismOptions | undefined\r\n  ): Promise<TRetVal[]> {\r\n    const result: TRetVal[] = [];\r\n\r\n    await Async.forEachAsync(\r\n      iterable,\r\n      async (item: TEntry, arrayIndex: number): Promise<void> => {\r\n        result[arrayIndex] = await callback(item, arrayIndex);\r\n      },\r\n      options\r\n    );\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Given an input array and a `callback` function, invoke the callback to start a\r\n   * promise for each element in the array.\r\n   *\r\n   * @remarks\r\n   * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,\r\n   * and the maximum number of concurrent promises can be throttled\r\n   * using {@link IAsyncParallelismOptions.concurrency}.\r\n   *\r\n   * If `callback` throws a synchronous exception, or if it returns a promise that rejects,\r\n   * then the loop stops immediately.  Any remaining array items will be skipped, and\r\n   * overall operation will reject with the first error that was encountered.\r\n   *\r\n   * @param iterable - the array of inputs for the callback function\r\n   * @param callback - a function that starts an asynchronous promise for an element\r\n   *   from the array\r\n   * @param options - options for customizing the control flow\r\n   */\r\n  public static async forEachAsync<TEntry>(\r\n    iterable: Iterable<TEntry> | AsyncIterable<TEntry>,\r\n    callback: (entry: TEntry, arrayIndex: number) => Promise<void>,\r\n    options?: IAsyncParallelismOptions | undefined\r\n  ): Promise<void> {\r\n    await new Promise<void>((resolve: () => void, reject: (error: Error) => void) => {\r\n      const concurrency: number =\r\n        options?.concurrency && options.concurrency > 0 ? options.concurrency : Infinity;\r\n      let operationsInProgress: number = 0;\r\n\r\n      const iterator: Iterator<TEntry> | AsyncIterator<TEntry> = (\r\n        (iterable as Iterable<TEntry>)[Symbol.iterator] ||\r\n        (iterable as AsyncIterable<TEntry>)[Symbol.asyncIterator]\r\n      ).call(iterable);\r\n\r\n      let arrayIndex: number = 0;\r\n      let iteratorIsComplete: boolean = false;\r\n      let promiseHasResolvedOrRejected: boolean = false;\r\n\r\n      async function queueOperationsAsync(): Promise<void> {\r\n        while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {\r\n          const currentIteratorResult: IteratorResult<TEntry> = await iterator.next();\r\n          // eslint-disable-next-line require-atomic-updates\r\n          iteratorIsComplete = !!currentIteratorResult.done;\r\n\r\n          if (!iteratorIsComplete) {\r\n            operationsInProgress++;\r\n            Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))\r\n              .then(async () => {\r\n                operationsInProgress--;\r\n                await onOperationCompletionAsync();\r\n              })\r\n              .catch((error) => {\r\n                promiseHasResolvedOrRejected = true;\r\n                reject(error);\r\n              });\r\n          }\r\n        }\r\n\r\n        if (iteratorIsComplete) {\r\n          await onOperationCompletionAsync();\r\n        }\r\n      }\r\n\r\n      async function onOperationCompletionAsync(): Promise<void> {\r\n        if (!promiseHasResolvedOrRejected) {\r\n          if (operationsInProgress === 0 && iteratorIsComplete) {\r\n            promiseHasResolvedOrRejected = true;\r\n            resolve();\r\n          } else if (!iteratorIsComplete) {\r\n            await queueOperationsAsync();\r\n          }\r\n        }\r\n      }\r\n\r\n      queueOperationsAsync().catch((error) => {\r\n        promiseHasResolvedOrRejected = true;\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that resolves after the specified number of milliseconds.\r\n   */\r\n  public static async sleep(ms: number): Promise<void> {\r\n    await new Promise((resolve) => {\r\n      setTimeout(resolve, ms);\r\n    });\r\n  }\r\n}\r\n"]}