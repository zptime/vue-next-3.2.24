{"code":"/**\r\n * This module is Node-only.\r\n */\r\nimport { createCallExpression, CREATE_STATIC } from '@vue/compiler-core';\r\nimport { isVoidTag, isString, isSymbol, isKnownHtmlAttr, escapeHtml, toDisplayString, normalizeClass, normalizeStyle, stringifyStyle, makeMap, isKnownSvgAttr } from '@vue/shared';\r\n/**\r\n * Regex for replacing placeholders for embedded constant variables\r\n * (e.g. import URL string constants generated by compiler-sfc)\r\n */\r\nconst expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;\r\n/**\r\n * Turn eligible hoisted static trees into stringified static nodes, e.g.\r\n *\r\n * ```js\r\n * const _hoisted_1 = createStaticVNode(`<div class=\"foo\">bar</div>`)\r\n * ```\r\n *\r\n * A single static vnode can contain stringified content for **multiple**\r\n * consecutive nodes (element and plain text), called a \"chunk\".\r\n * `@vue/runtime-dom` will create the content via innerHTML in a hidden\r\n * container element and insert all the nodes in place. The call must also\r\n * provide the number of nodes contained in the chunk so that during hydration\r\n * we can know how many nodes the static vnode should adopt.\r\n *\r\n * The optimization scans a children list that contains hoisted nodes, and\r\n * tries to find the largest chunk of consecutive hoisted nodes before running\r\n * into a non-hoisted node or the end of the list. A chunk is then converted\r\n * into a single static vnode and replaces the hoisted expression of the first\r\n * node in the chunk. Other nodes in the chunk are considered \"merged\" and\r\n * therefore removed from both the hoist list and the children array.\r\n *\r\n * This optimization is only performed in Node.js.\r\n */\r\nexport const stringifyStatic = (children, context, parent) => {\r\n    // bail stringification for slot content\r\n    if (context.scopes.vSlot > 0) {\r\n        return;\r\n    }\r\n    let nc = 0; // current node count\r\n    let ec = 0; // current element with binding count\r\n    const currentChunk = [];\r\n    const stringifyCurrentChunk = (currentIndex) => {\r\n        if (nc >= 20 /* NODE_COUNT */ ||\r\n            ec >= 5 /* ELEMENT_WITH_BINDING_COUNT */) {\r\n            // combine all currently eligible nodes into a single static vnode call\r\n            const staticCall = createCallExpression(context.helper(CREATE_STATIC), [\r\n                JSON.stringify(currentChunk.map(node => stringifyNode(node, context)).join('')).replace(expReplaceRE, `\" + $1 + \"`),\r\n                // the 2nd argument indicates the number of DOM nodes this static vnode\r\n                // will insert / hydrate\r\n                String(currentChunk.length)\r\n            ]);\r\n            // replace the first node's hoisted expression with the static vnode call\r\n            replaceHoist(currentChunk[0], staticCall, context);\r\n            if (currentChunk.length > 1) {\r\n                for (let i = 1; i < currentChunk.length; i++) {\r\n                    // for the merged nodes, set their hoisted expression to null\r\n                    replaceHoist(currentChunk[i], null, context);\r\n                }\r\n                // also remove merged nodes from children\r\n                const deleteCount = currentChunk.length - 1;\r\n                children.splice(currentIndex - currentChunk.length + 1, deleteCount);\r\n                return deleteCount;\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    let i = 0;\r\n    for (; i < children.length; i++) {\r\n        const child = children[i];\r\n        const hoisted = getHoistedNode(child);\r\n        if (hoisted) {\r\n            // presence of hoisted means child must be a stringifiable node\r\n            const node = child;\r\n            const result = analyzeNode(node);\r\n            if (result) {\r\n                // node is stringifiable, record state\r\n                nc += result[0];\r\n                ec += result[1];\r\n                currentChunk.push(node);\r\n                continue;\r\n            }\r\n        }\r\n        // we only reach here if we ran into a node that is not stringifiable\r\n        // check if currently analyzed nodes meet criteria for stringification.\r\n        // adjust iteration index\r\n        i -= stringifyCurrentChunk(i);\r\n        // reset state\r\n        nc = 0;\r\n        ec = 0;\r\n        currentChunk.length = 0;\r\n    }\r\n    // in case the last node was also stringifiable\r\n    stringifyCurrentChunk(i);\r\n};\r\nconst getHoistedNode = (node) => ((node.type === 1 /* ELEMENT */ && node.tagType === 0 /* ELEMENT */) ||\r\n    node.type == 12 /* TEXT_CALL */) &&\r\n    node.codegenNode &&\r\n    node.codegenNode.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n    node.codegenNode.hoisted;\r\nconst dataAriaRE = /^(data|aria)-/;\r\nconst isStringifiableAttr = (name, ns) => {\r\n    return ((ns === 0 /* HTML */\r\n        ? isKnownHtmlAttr(name)\r\n        : ns === 1 /* SVG */\r\n            ? isKnownSvgAttr(name)\r\n            : false) || dataAriaRE.test(name));\r\n};\r\nconst replaceHoist = (node, replacement, context) => {\r\n    const hoistToReplace = node.codegenNode.hoisted;\r\n    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;\r\n};\r\nconst isNonStringifiable = /*#__PURE__*/ makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);\r\n/**\r\n * for a hoisted node, analyze it and return:\r\n * - false: bailed (contains non-stringifiable props or runtime constant)\r\n * - [nc, ec] where\r\n *   - nc is the number of nodes inside\r\n *   - ec is the number of element with bindings inside\r\n */\r\nfunction analyzeNode(node) {\r\n    if (node.type === 1 /* ELEMENT */ && isNonStringifiable(node.tag)) {\r\n        return false;\r\n    }\r\n    if (node.type === 12 /* TEXT_CALL */) {\r\n        return [1, 0];\r\n    }\r\n    let nc = 1; // node count\r\n    let ec = node.props.length > 0 ? 1 : 0; // element w/ binding count\r\n    let bailed = false;\r\n    const bail = () => {\r\n        bailed = true;\r\n        return false;\r\n    };\r\n    // TODO: check for cases where using innerHTML will result in different\r\n    // output compared to imperative node insertions.\r\n    // probably only need to check for most common case\r\n    // i.e. non-phrasing-content tags inside `<p>`\r\n    function walk(node) {\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i];\r\n            // bail on non-attr bindings\r\n            if (p.type === 6 /* ATTRIBUTE */ &&\r\n                !isStringifiableAttr(p.name, node.ns)) {\r\n                return bail();\r\n            }\r\n            if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind') {\r\n                // bail on non-attr bindings\r\n                if (p.arg &&\r\n                    (p.arg.type === 8 /* COMPOUND_EXPRESSION */ ||\r\n                        (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))) {\r\n                    return bail();\r\n                }\r\n                if (p.exp &&\r\n                    (p.exp.type === 8 /* COMPOUND_EXPRESSION */ ||\r\n                        p.exp.constType < 3 /* CAN_STRINGIFY */)) {\r\n                    return bail();\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            nc++;\r\n            const child = node.children[i];\r\n            if (child.type === 1 /* ELEMENT */) {\r\n                if (child.props.length > 0) {\r\n                    ec++;\r\n                }\r\n                walk(child);\r\n                if (bailed) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return walk(node) ? [nc, ec] : false;\r\n}\r\nfunction stringifyNode(node, context) {\r\n    if (isString(node)) {\r\n        return node;\r\n    }\r\n    if (isSymbol(node)) {\r\n        return ``;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            return stringifyElement(node, context);\r\n        case 2 /* TEXT */:\r\n            return escapeHtml(node.content);\r\n        case 3 /* COMMENT */:\r\n            return `<!--${escapeHtml(node.content)}-->`;\r\n        case 5 /* INTERPOLATION */:\r\n            return escapeHtml(toDisplayString(evaluateConstant(node.content)));\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            return escapeHtml(evaluateConstant(node));\r\n        case 12 /* TEXT_CALL */:\r\n            return stringifyNode(node.content, context);\r\n        default:\r\n            // static trees will not contain if/for nodes\r\n            return '';\r\n    }\r\n}\r\nfunction stringifyElement(node, context) {\r\n    let res = `<${node.tag}`;\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            res += ` ${p.name}`;\r\n            if (p.value) {\r\n                res += `=\"${escapeHtml(p.value.content)}\"`;\r\n            }\r\n        }\r\n        else if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind') {\r\n            const exp = p.exp;\r\n            if (exp.content[0] === '_') {\r\n                // internally generated string constant references\r\n                // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin\r\n                res += ` ${p.arg.content}=\"__VUE_EXP_START__${exp.content}__VUE_EXP_END__\"`;\r\n                continue;\r\n            }\r\n            // constant v-bind, e.g. :foo=\"1\"\r\n            let evaluated = evaluateConstant(exp);\r\n            if (evaluated != null) {\r\n                const arg = p.arg && p.arg.content;\r\n                if (arg === 'class') {\r\n                    evaluated = normalizeClass(evaluated);\r\n                }\r\n                else if (arg === 'style') {\r\n                    evaluated = stringifyStyle(normalizeStyle(evaluated));\r\n                }\r\n                res += ` ${p.arg.content}=\"${escapeHtml(evaluated)}\"`;\r\n            }\r\n        }\r\n    }\r\n    if (context.scopeId) {\r\n        res += ` ${context.scopeId}`;\r\n    }\r\n    res += `>`;\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        res += stringifyNode(node.children[i], context);\r\n    }\r\n    if (!isVoidTag(node.tag)) {\r\n        res += `</${node.tag}>`;\r\n    }\r\n    return res;\r\n}\r\n// __UNSAFE__\r\n// Reason: eval.\r\n// It's technically safe to eval because only constant expressions are possible\r\n// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`\r\n// in addition, constant exps bail on presence of parens so you can't even\r\n// run JSFuck in here. But we mark it unsafe for security review purposes.\r\n// (see compiler-core/src/transformExpressions)\r\nfunction evaluateConstant(exp) {\r\n    if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        return new Function(`return ${exp.content}`)();\r\n    }\r\n    else {\r\n        // compound\r\n        let res = ``;\r\n        exp.children.forEach(c => {\r\n            if (isString(c) || isSymbol(c)) {\r\n                return;\r\n            }\r\n            if (c.type === 2 /* TEXT */) {\r\n                res += c.content;\r\n            }\r\n            else if (c.type === 5 /* INTERPOLATION */) {\r\n                res += toDisplayString(evaluateConstant(c.content));\r\n            }\r\n            else {\r\n                res += evaluateConstant(c);\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n}\r\n","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-dom/src/parserOptions.ts"]}
