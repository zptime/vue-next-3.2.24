{"code":"import { camelize, extend, hyphenate, isArray, isObject, isReservedProp, normalizeClass } from '@vue/shared';\r\nimport { createSlots } from '../helpers/createSlots';\r\nimport { renderSlot } from '../helpers/renderSlot';\r\nimport { toHandlers } from '../helpers/toHandlers';\r\nimport { mergeProps } from '../vnode';\r\nfunction toObject(arr) {\r\n    const res = {};\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (arr[i]) {\r\n            extend(res, arr[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexport function legacyBindObjectProps(data, _tag, value, _asProp, isSync) {\r\n    if (value && isObject(value)) {\r\n        if (isArray(value)) {\r\n            value = toObject(value);\r\n        }\r\n        for (const key in value) {\r\n            if (isReservedProp(key)) {\r\n                data[key] = value[key];\r\n            }\r\n            else if (key === 'class') {\r\n                data.class = normalizeClass([data.class, value.class]);\r\n            }\r\n            else if (key === 'style') {\r\n                data.style = normalizeClass([data.style, value.style]);\r\n            }\r\n            else {\r\n                const attrs = data.attrs || (data.attrs = {});\r\n                const camelizedKey = camelize(key);\r\n                const hyphenatedKey = hyphenate(key);\r\n                if (!(camelizedKey in attrs) && !(hyphenatedKey in attrs)) {\r\n                    attrs[key] = value[key];\r\n                    if (isSync) {\r\n                        const on = data.on || (data.on = {});\r\n                        on[`update:${key}`] = function ($event) {\r\n                            value[key] = $event;\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\r\nexport function legacyBindObjectListeners(props, listeners) {\r\n    return mergeProps(props, toHandlers(listeners));\r\n}\r\nexport function legacyRenderSlot(instance, name, fallback, props, bindObject) {\r\n    if (bindObject) {\r\n        props = mergeProps(props, bindObject);\r\n    }\r\n    return renderSlot(instance.slots, name, props, fallback && (() => fallback));\r\n}\r\nexport function legacyresolveScopedSlots(fns, raw, \r\n// the following are added in 2.6\r\nhasDynamicKeys) {\r\n    // v2 default slot doesn't have name\r\n    return createSlots(raw || { $stable: !hasDynamicKeys }, mapKeyToName(fns));\r\n}\r\nfunction mapKeyToName(slots) {\r\n    for (let i = 0; i < slots.length; i++) {\r\n        const fn = slots[i];\r\n        if (fn) {\r\n            if (isArray(fn)) {\r\n                mapKeyToName(fn);\r\n            }\r\n            else {\r\n                ;\r\n                fn.name = fn.key || 'default';\r\n            }\r\n        }\r\n    }\r\n    return slots;\r\n}\r\nconst staticCacheMap = /*#__PURE__*/ new WeakMap();\r\nexport function legacyRenderStatic(instance, index) {\r\n    let cache = staticCacheMap.get(instance);\r\n    if (!cache) {\r\n        staticCacheMap.set(instance, (cache = []));\r\n    }\r\n    if (cache[index]) {\r\n        return cache[index];\r\n    }\r\n    const fn = instance.type.staticRenderFns[index];\r\n    const ctx = instance.proxy;\r\n    return (cache[index] = fn.call(ctx, null, ctx));\r\n}\r\nexport function legacyCheckKeyCodes(instance, eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\r\n    const config = instance.appContext.config;\r\n    const configKeyCodes = config.keyCodes || {};\r\n    const mappedKeyCode = configKeyCodes[key] || builtInKeyCode;\r\n    if (builtInKeyName && eventKeyName && !configKeyCodes[key]) {\r\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\r\n    }\r\n    else if (mappedKeyCode) {\r\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\r\n    }\r\n    else if (eventKeyName) {\r\n        return hyphenate(eventKeyName) !== key;\r\n    }\r\n}\r\nfunction isKeyNotMatch(expect, actual) {\r\n    if (isArray(expect)) {\r\n        return expect.indexOf(actual) === -1;\r\n    }\r\n    else {\r\n        return expect !== actual;\r\n    }\r\n}\r\nexport function legacyMarkOnce(tree) {\r\n    return tree;\r\n}\r\nexport function legacyBindDynamicKeys(props, values) {\r\n    for (let i = 0; i < values.length; i += 2) {\r\n        const key = values[i];\r\n        if (typeof key === 'string' && key) {\r\n            props[values[i]] = values[i + 1];\r\n        }\r\n    }\r\n    return props;\r\n}\r\nexport function legacyPrependModifier(value, symbol) {\r\n    return typeof value === 'string' ? symbol + value : value;\r\n}\r\n","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/component.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/componentSlots.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/helpers/createSlots.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/helpers/renderSlot.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/helpers/toHandlers.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/vnode.ts"]}
