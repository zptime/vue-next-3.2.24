{"code":"import { createObjectExpression, createObjectProperty, createSimpleExpression, createFunctionExpression, createConditionalExpression, createCallExpression, createArrayExpression } from '../ast';\r\nimport { createCompilerError } from '../errors';\r\nimport { findDir, isTemplateNode, assert, isVSlot, hasScopeRef, isStaticExp } from '../utils';\r\nimport { CREATE_SLOTS, RENDER_LIST, WITH_CTX } from '../runtimeHelpers';\r\nimport { parseForExpression, createForLoopParams } from './vFor';\r\nimport { slotFlagsText } from '@vue/shared';\r\nconst defaultFallback = createSimpleExpression(`undefined`, false);\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nexport const trackSlotScopes = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 1 /* COMPONENT */ ||\r\n            node.tagType === 3 /* TEMPLATE */)) {\r\n        // We are only checking non-empty v-slot here\r\n        // since we only care about slots that introduce scope variables.\r\n        const vSlot = findDir(node, 'slot');\r\n        if (vSlot) {\r\n            const slotProps = vSlot.exp;\r\n            if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                slotProps && context.addIdentifiers(slotProps);\r\n            }\r\n            context.scopes.vSlot++;\r\n            return () => {\r\n                if (!__BROWSER__ && context.prefixIdentifiers) {\r\n                    slotProps && context.removeIdentifiers(slotProps);\r\n                }\r\n                context.scopes.vSlot--;\r\n            };\r\n        }\r\n    }\r\n};\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nexport const trackVForSlotScopes = (node, context) => {\r\n    let vFor;\r\n    if (isTemplateNode(node) &&\r\n        node.props.some(isVSlot) &&\r\n        (vFor = findDir(node, 'for'))) {\r\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\r\n        if (result) {\r\n            const { value, key, index } = result;\r\n            const { addIdentifiers, removeIdentifiers } = context;\r\n            value && addIdentifiers(value);\r\n            key && addIdentifiers(key);\r\n            index && addIdentifiers(index);\r\n            return () => {\r\n                value && removeIdentifiers(value);\r\n                key && removeIdentifiers(key);\r\n                index && removeIdentifiers(index);\r\n            };\r\n        }\r\n    }\r\n};\r\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nexport function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\r\n    context.helper(WITH_CTX);\r\n    const { children, loc } = node;\r\n    const slotsProperties = [];\r\n    const dynamicSlots = [];\r\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n    // since it likely uses a scope variable.\r\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n    // with `prefixIdentifiers: true`, this can be further optimized to make\r\n    // it dynamic only when the slot actually uses the scope variables.\r\n    if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {\r\n        hasDynamicSlots = hasScopeRef(node, context.identifiers);\r\n    }\r\n    // 1. Check for slot with slotProps on component itself.\r\n    //    <Comp v-slot=\"{ prop }\"/>\r\n    const onComponentSlot = findDir(node, 'slot', true);\r\n    if (onComponentSlot) {\r\n        const { arg, exp } = onComponentSlot;\r\n        if (arg && !isStaticExp(arg)) {\r\n            hasDynamicSlots = true;\r\n        }\r\n        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));\r\n    }\r\n    // 2. Iterate through children and check for template slots\r\n    //    <template v-slot:foo=\"{ prop }\">\r\n    let hasTemplateSlots = false;\r\n    let hasNamedDefaultSlot = false;\r\n    const implicitDefaultChildren = [];\r\n    const seenSlotNames = new Set();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const slotElement = children[i];\r\n        let slotDir;\r\n        if (!isTemplateNode(slotElement) ||\r\n            !(slotDir = findDir(slotElement, 'slot', true))) {\r\n            // not a <template v-slot>, skip.\r\n            if (slotElement.type !== 3 /* COMMENT */) {\r\n                implicitDefaultChildren.push(slotElement);\r\n            }\r\n            continue;\r\n        }\r\n        if (onComponentSlot) {\r\n            // already has on-component slot - this is incorrect usage.\r\n            context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\r\n            break;\r\n        }\r\n        hasTemplateSlots = true;\r\n        const { children: slotChildren, loc: slotLoc } = slotElement;\r\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n        // check if name is dynamic.\r\n        let staticSlotName;\r\n        if (isStaticExp(slotName)) {\r\n            staticSlotName = slotName ? slotName.content : `default`;\r\n        }\r\n        else {\r\n            hasDynamicSlots = true;\r\n        }\r\n        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\r\n        // check if this slot is conditional (v-if/v-for)\r\n        let vIf;\r\n        let vElse;\r\n        let vFor;\r\n        if ((vIf = findDir(slotElement, 'if'))) {\r\n            hasDynamicSlots = true;\r\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n        }\r\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n            // find adjacent v-if\r\n            let j = i;\r\n            let prev;\r\n            while (j--) {\r\n                prev = children[j];\r\n                if (prev.type !== 3 /* COMMENT */) {\r\n                    break;\r\n                }\r\n            }\r\n            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n                // remove node\r\n                children.splice(i, 1);\r\n                i--;\r\n                __TEST__ && assert(dynamicSlots.length > 0);\r\n                // attach this slot to previous conditional\r\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                    conditional = conditional.alternate;\r\n                }\r\n                conditional.alternate = vElse.exp\r\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                    : buildDynamicSlot(slotName, slotFunction);\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n            }\r\n        }\r\n        else if ((vFor = findDir(slotElement, 'for'))) {\r\n            hasDynamicSlots = true;\r\n            const parseResult = vFor.parseResult ||\r\n                parseForExpression(vFor.exp, context);\r\n            if (parseResult) {\r\n                // Render the dynamic slots as an array and add it to the createSlot()\r\n                // args. The runtime knows how to handle it appropriately.\r\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                    parseResult.source,\r\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\r\n                ]));\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n            }\r\n        }\r\n        else {\r\n            // check duplicate static names\r\n            if (staticSlotName) {\r\n                if (seenSlotNames.has(staticSlotName)) {\r\n                    context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                    continue;\r\n                }\r\n                seenSlotNames.add(staticSlotName);\r\n                if (staticSlotName === 'default') {\r\n                    hasNamedDefaultSlot = true;\r\n                }\r\n            }\r\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n        }\r\n    }\r\n    if (!onComponentSlot) {\r\n        const buildDefaultSlotProperty = (props, children) => {\r\n            const fn = buildSlotFn(props, children, loc);\r\n            if (__COMPAT__ && context.compatConfig) {\r\n                fn.isNonScopedSlot = true;\r\n            }\r\n            return createObjectProperty(`default`, fn);\r\n        };\r\n        if (!hasTemplateSlots) {\r\n            // implicit default slot (on component)\r\n            slotsProperties.push(buildDefaultSlotProperty(undefined, children));\r\n        }\r\n        else if (implicitDefaultChildren.length &&\r\n            // #3766\r\n            // with whitespace: 'preserve', whitespaces between slots will end up in\r\n            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\r\n            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {\r\n            // implicit default slot (mixed with named slots)\r\n            if (hasNamedDefaultSlot) {\r\n                context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\r\n            }\r\n            else {\r\n                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\r\n            }\r\n        }\r\n    }\r\n    const slotFlag = hasDynamicSlots\r\n        ? 2 /* DYNAMIC */\r\n        : hasForwardedSlots(node.children)\r\n            ? 3 /* FORWARDED */\r\n            : 1 /* STABLE */;\r\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \r\n    // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n    // 1 = compiled and static = can skip normalization AND diff as optimized\r\n    createSimpleExpression(slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);\r\n    if (dynamicSlots.length) {\r\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n            slots,\r\n            createArrayExpression(dynamicSlots)\r\n        ]);\r\n    }\r\n    return {\r\n        slots,\r\n        hasDynamicSlots\r\n    };\r\n}\r\nfunction buildDynamicSlot(name, fn) {\r\n    return createObjectExpression([\r\n        createObjectProperty(`name`, name),\r\n        createObjectProperty(`fn`, fn)\r\n    ]);\r\n}\r\nfunction hasForwardedSlots(children) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        switch (child.type) {\r\n            case 1 /* ELEMENT */:\r\n                if (child.tagType === 2 /* SLOT */ ||\r\n                    hasForwardedSlots(child.children)) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 9 /* IF */:\r\n                if (hasForwardedSlots(child.branches))\r\n                    return true;\r\n                break;\r\n            case 10 /* IF_BRANCH */:\r\n            case 11 /* FOR */:\r\n                if (hasForwardedSlots(child.children))\r\n                    return true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction isNonWhitespaceContent(node) {\r\n    if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)\r\n        return true;\r\n    return node.type === 2 /* TEXT */\r\n        ? !!node.content.trim()\r\n        : isNonWhitespaceContent(node.content);\r\n}\r\n","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/ast.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/transform.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/errors.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/utils.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/runtimeHelpers.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/transforms/vFor.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts"]}
