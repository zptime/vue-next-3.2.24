{"code":"import { extend, hyphenate, isArray, isObject, isString, makeMap, normalizeClass, normalizeStyle, toHandlerKey } from '@vue/shared';\r\nimport { currentRenderingInstance } from '../componentRenderContext';\r\nimport { withDirectives } from '../directives';\r\nimport { resolveDirective, resolveDynamicComponent } from '../helpers/resolveAssets';\r\nimport { Comment, createVNode, isVNode, normalizeChildren } from '../vnode';\r\nimport { checkCompatEnabled, isCompatEnabled } from './compatConfig';\r\nimport { compatModelEventPrefix } from './componentVModel';\r\nexport function convertLegacyRenderFn(instance) {\r\n    const Component = instance.type;\r\n    const render = Component.render;\r\n    // v3 runtime compiled, or already checked / wrapped\r\n    if (!render || render._rc || render._compatChecked || render._compatWrapped) {\r\n        return;\r\n    }\r\n    if (render.length >= 2) {\r\n        // v3 pre-compiled function, since v2 render functions never need more than\r\n        // 2 arguments, and v2 functional render functions would have already been\r\n        // normalized into v3 functional components\r\n        render._compatChecked = true;\r\n        return;\r\n    }\r\n    // v2 render function, try to provide compat\r\n    if (checkCompatEnabled(\"RENDER_FUNCTION\" /* RENDER_FUNCTION */, instance)) {\r\n        const wrapped = (Component.render = function compatRender() {\r\n            // @ts-ignore\r\n            return render.call(this, compatH);\r\n        });\r\n        // @ts-ignore\r\n        wrapped._compatWrapped = true;\r\n    }\r\n}\r\nexport function compatH(type, propsOrChildren, children) {\r\n    if (!type) {\r\n        type = Comment;\r\n    }\r\n    // to support v2 string component name look!up\r\n    if (typeof type === 'string') {\r\n        const t = hyphenate(type);\r\n        if (t === 'transition' || t === 'transition-group' || t === 'keep-alive') {\r\n            // since transition and transition-group are runtime-dom-specific,\r\n            // we cannot import them directly here. Instead they are registered using\r\n            // special keys in @vue/compat entry.\r\n            type = `__compat__${t}`;\r\n        }\r\n        type = resolveDynamicComponent(type);\r\n    }\r\n    const l = arguments.length;\r\n    const is2ndArgArrayChildren = isArray(propsOrChildren);\r\n    if (l === 2 || is2ndArgArrayChildren) {\r\n        if (isObject(propsOrChildren) && !is2ndArgArrayChildren) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return convertLegacySlots(createVNode(type, null, [propsOrChildren]));\r\n            }\r\n            // props without children\r\n            return convertLegacySlots(convertLegacyDirectives(createVNode(type, convertLegacyProps(propsOrChildren, type)), propsOrChildren));\r\n        }\r\n        else {\r\n            // omit props\r\n            return convertLegacySlots(createVNode(type, null, propsOrChildren));\r\n        }\r\n    }\r\n    else {\r\n        if (isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return convertLegacySlots(convertLegacyDirectives(createVNode(type, convertLegacyProps(propsOrChildren, type), children), propsOrChildren));\r\n    }\r\n}\r\nconst skipLegacyRootLevelProps = /*#__PURE__*/ makeMap('staticStyle,staticClass,directives,model,hook');\r\nfunction convertLegacyProps(legacyProps, type) {\r\n    if (!legacyProps) {\r\n        return null;\r\n    }\r\n    const converted = {};\r\n    for (const key in legacyProps) {\r\n        if (key === 'attrs' || key === 'domProps' || key === 'props') {\r\n            extend(converted, legacyProps[key]);\r\n        }\r\n        else if (key === 'on' || key === 'nativeOn') {\r\n            const listeners = legacyProps[key];\r\n            for (const event in listeners) {\r\n                let handlerKey = convertLegacyEventKey(event);\r\n                if (key === 'nativeOn')\r\n                    handlerKey += `Native`;\r\n                const existing = converted[handlerKey];\r\n                const incoming = listeners[event];\r\n                if (existing !== incoming) {\r\n                    if (existing) {\r\n                        converted[handlerKey] = [].concat(existing, incoming);\r\n                    }\r\n                    else {\r\n                        converted[handlerKey] = incoming;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (!skipLegacyRootLevelProps(key)) {\r\n            converted[key] = legacyProps[key];\r\n        }\r\n    }\r\n    if (legacyProps.staticClass) {\r\n        converted.class = normalizeClass([legacyProps.staticClass, converted.class]);\r\n    }\r\n    if (legacyProps.staticStyle) {\r\n        converted.style = normalizeStyle([legacyProps.staticStyle, converted.style]);\r\n    }\r\n    if (legacyProps.model && isObject(type)) {\r\n        // v2 compiled component v-model\r\n        const { prop = 'value', event = 'input' } = type.model || {};\r\n        converted[prop] = legacyProps.model.value;\r\n        converted[compatModelEventPrefix + event] = legacyProps.model.callback;\r\n    }\r\n    return converted;\r\n}\r\nfunction convertLegacyEventKey(event) {\r\n    // normalize v2 event prefixes\r\n    if (event[0] === '&') {\r\n        event = event.slice(1) + 'Passive';\r\n    }\r\n    if (event[0] === '~') {\r\n        event = event.slice(1) + 'Once';\r\n    }\r\n    if (event[0] === '!') {\r\n        event = event.slice(1) + 'Capture';\r\n    }\r\n    return toHandlerKey(event);\r\n}\r\nfunction convertLegacyDirectives(vnode, props) {\r\n    if (props && props.directives) {\r\n        return withDirectives(vnode, props.directives.map(({ name, value, arg, modifiers }) => {\r\n            return [\r\n                resolveDirective(name),\r\n                value,\r\n                arg,\r\n                modifiers\r\n            ];\r\n        }));\r\n    }\r\n    return vnode;\r\n}\r\nfunction convertLegacySlots(vnode) {\r\n    const { props, children } = vnode;\r\n    let slots;\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && isArray(children)) {\r\n        slots = {};\r\n        // check \"slot\" property on vnodes and turn them into v3 function slots\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            const slotName = (isVNode(child) && child.props && child.props.slot) || 'default';\r\n            const slot = slots[slotName] || (slots[slotName] = []);\r\n            if (isVNode(child) && child.type === 'template') {\r\n                slot.push(child.children);\r\n            }\r\n            else {\r\n                slot.push(child);\r\n            }\r\n        }\r\n        if (slots) {\r\n            for (const key in slots) {\r\n                const slotChildren = slots[key];\r\n                slots[key] = () => slotChildren;\r\n                slots[key]._ns = true; /* non-scoped slot */\r\n            }\r\n        }\r\n    }\r\n    const scopedSlots = props && props.scopedSlots;\r\n    if (scopedSlots) {\r\n        delete props.scopedSlots;\r\n        if (slots) {\r\n            extend(slots, scopedSlots);\r\n        }\r\n        else {\r\n            slots = scopedSlots;\r\n        }\r\n    }\r\n    if (slots) {\r\n        normalizeChildren(vnode, slots);\r\n    }\r\n    return vnode;\r\n}\r\nexport function defineLegacyVNodeProperties(vnode) {\r\n    /* istanbul ignore if */\r\n    if (isCompatEnabled(\"RENDER_FUNCTION\" /* RENDER_FUNCTION */, currentRenderingInstance, true /* enable for built-ins */) &&\r\n        isCompatEnabled(\"PRIVATE_APIS\" /* PRIVATE_APIS */, currentRenderingInstance, true /* enable for built-ins */)) {\r\n        const context = currentRenderingInstance;\r\n        const getInstance = () => vnode.component && vnode.component.proxy;\r\n        let componentOptions;\r\n        Object.defineProperties(vnode, {\r\n            tag: { get: () => vnode.type },\r\n            data: { get: () => vnode.props || {}, set: p => (vnode.props = p) },\r\n            elm: { get: () => vnode.el },\r\n            componentInstance: { get: getInstance },\r\n            child: { get: getInstance },\r\n            text: { get: () => (isString(vnode.children) ? vnode.children : null) },\r\n            context: { get: () => context && context.proxy },\r\n            componentOptions: {\r\n                get: () => {\r\n                    if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n                        if (componentOptions) {\r\n                            return componentOptions;\r\n                        }\r\n                        return (componentOptions = {\r\n                            Ctor: vnode.type,\r\n                            propsData: vnode.props,\r\n                            children: vnode.children\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/component.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/componentRenderContext.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/directives.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/helpers/resolveAssets.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/vnode.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/compat/compatConfig.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/compat/componentVModel.ts"]}
