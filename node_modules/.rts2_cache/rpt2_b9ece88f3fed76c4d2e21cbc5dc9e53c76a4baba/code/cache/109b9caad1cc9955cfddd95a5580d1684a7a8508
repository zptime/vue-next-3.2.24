{"code":"import { createSimpleExpression, createCompoundExpression } from '../ast';\r\nimport { isInDestructureAssignment, isStaticProperty, isStaticPropertyKey, walkIdentifiers } from '../babelUtils';\r\nimport { advancePositionWithClone, isSimpleIdentifier } from '../utils';\r\nimport { isGloballyWhitelisted, makeMap, hasOwn, isString } from '@vue/shared';\r\nimport { createCompilerError } from '../errors';\r\nimport { validateBrowserExpression } from '../validateExpression';\r\nimport { parse } from '@babel/parser';\r\nimport { IS_REF, UNREF } from '../runtimeHelpers';\r\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this');\r\nexport const transformExpression = (node, context) => {\r\n    if (node.type === 5 /* INTERPOLATION */) {\r\n        node.content = processExpression(node.content, context);\r\n    }\r\n    else if (node.type === 1 /* ELEMENT */) {\r\n        // handle directives on element\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const dir = node.props[i];\r\n            // do not process for v-on & v-for since they are special handled\r\n            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {\r\n                const exp = dir.exp;\r\n                const arg = dir.arg;\r\n                // do not process exp if this is v-on:arg - we need special handling\r\n                // for wrapping inline statements.\r\n                if (exp &&\r\n                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                    !(dir.name === 'on' && arg)) {\r\n                    dir.exp = processExpression(exp, context, \r\n                    // slot args must be processed as function params\r\n                    dir.name === 'slot');\r\n                }\r\n                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\r\n                    dir.arg = processExpression(arg, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !__BROWSER__ check so that it can be\r\n// tree-shaken from the browser build.\r\nexport function processExpression(node, context, \r\n// some expressions like v-slot props & v-for aliases should be parsed as\r\n// function params\r\nasParams = false, \r\n// v-on handler values may contain multiple statements\r\nasRawStatements = false, localVars = Object.create(context.identifiers)) {\r\n    if (__BROWSER__) {\r\n        if (__DEV__) {\r\n            // simple in-browser validation (same logic in 2.x)\r\n            validateBrowserExpression(node, context, asParams, asRawStatements);\r\n        }\r\n        return node;\r\n    }\r\n    if (!context.prefixIdentifiers || !node.content.trim()) {\r\n        return node;\r\n    }\r\n    const { inline, bindingMetadata } = context;\r\n    const rewriteIdentifier = (raw, parent, id) => {\r\n        const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw];\r\n        if (inline) {\r\n            // x = y\r\n            const isAssignmentLVal = parent && parent.type === 'AssignmentExpression' && parent.left === id;\r\n            // x++\r\n            const isUpdateArg = parent && parent.type === 'UpdateExpression' && parent.argument === id;\r\n            // ({ x } = y)\r\n            const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);\r\n            if (type === \"setup-const\" /* SETUP_CONST */ || localVars[raw]) {\r\n                return raw;\r\n            }\r\n            else if (type === \"setup-ref\" /* SETUP_REF */) {\r\n                return `${raw}.value`;\r\n            }\r\n            else if (type === \"setup-maybe-ref\" /* SETUP_MAYBE_REF */) {\r\n                // const binding that may or may not be ref\r\n                // if it's not a ref, then assignments don't make sense -\r\n                // so we ignore the non-ref assignment case and generate code\r\n                // that assumes the value to be a ref for more efficiency\r\n                return isAssignmentLVal || isUpdateArg || isDestructureAssignment\r\n                    ? `${raw}.value`\r\n                    : `${context.helperString(UNREF)}(${raw})`;\r\n            }\r\n            else if (type === \"setup-let\" /* SETUP_LET */) {\r\n                if (isAssignmentLVal) {\r\n                    // let binding.\r\n                    // this is a bit more tricky as we need to cover the case where\r\n                    // let is a local non-ref value, and we need to replicate the\r\n                    // right hand side value.\r\n                    // x = y --> isRef(x) ? x.value = y : x = y\r\n                    const { right: rVal, operator } = parent;\r\n                    const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);\r\n                    const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context, false, false, knownIds));\r\n                    return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\\n` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;\r\n                }\r\n                else if (isUpdateArg) {\r\n                    // make id replace parent in the code range so the raw update operator\r\n                    // is removed\r\n                    id.start = parent.start;\r\n                    id.end = parent.end;\r\n                    const { prefix: isPrefix, operator } = parent;\r\n                    const prefix = isPrefix ? operator : ``;\r\n                    const postfix = isPrefix ? `` : operator;\r\n                    // let binding.\r\n                    // x++ --> isRef(a) ? a.value++ : a++\r\n                    return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\\n` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;\r\n                }\r\n                else if (isDestructureAssignment) {\r\n                    // TODO\r\n                    // let binding in a destructure assignment - it's very tricky to\r\n                    // handle both possible cases here without altering the original\r\n                    // structure of the code, so we just assume it's not a ref here\r\n                    // for now\r\n                    return raw;\r\n                }\r\n                else {\r\n                    return `${context.helperString(UNREF)}(${raw})`;\r\n                }\r\n            }\r\n            else if (type === \"props\" /* PROPS */) {\r\n                // use __props which is generated by compileScript so in ts mode\r\n                // it gets correct type\r\n                return `__props.${raw}`;\r\n            }\r\n            else if (type === \"props-aliased\" /* PROPS_ALIASED */) {\r\n                // prop with a different local alias (from defineProps() destructure)\r\n                return `__props.${bindingMetadata.__propsAliases[raw]}`;\r\n            }\r\n        }\r\n        else {\r\n            if (type && type.startsWith('setup')) {\r\n                // setup bindings in non-inline mode\r\n                return `$setup.${raw}`;\r\n            }\r\n            else if (type === \"props-aliased\" /* PROPS_ALIASED */) {\r\n                return `$props.${bindingMetadata.__propsAliases[raw]}`;\r\n            }\r\n            else if (type) {\r\n                return `$${type}.${raw}`;\r\n            }\r\n        }\r\n        // fallback to ctx\r\n        return `_ctx.${raw}`;\r\n    };\r\n    // fast path if expression is a simple identifier.\r\n    const rawExp = node.content;\r\n    // bail constant on parens (function invocation) and dot (member access)\r\n    const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0;\r\n    if (isSimpleIdentifier(rawExp)) {\r\n        const isScopeVarReference = context.identifiers[rawExp];\r\n        const isAllowedGlobal = isGloballyWhitelisted(rawExp);\r\n        const isLiteral = isLiteralWhitelisted(rawExp);\r\n        if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {\r\n            // const bindings exposed from setup can be skipped for patching but\r\n            // cannot be hoisted to module scope\r\n            if (bindingMetadata[node.content] === \"setup-const\" /* SETUP_CONST */) {\r\n                node.constType = 1 /* CAN_SKIP_PATCH */;\r\n            }\r\n            node.content = rewriteIdentifier(rawExp);\r\n        }\r\n        else if (!isScopeVarReference) {\r\n            if (isLiteral) {\r\n                node.constType = 3 /* CAN_STRINGIFY */;\r\n            }\r\n            else {\r\n                node.constType = 2 /* CAN_HOIST */;\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n    let ast;\r\n    // exp needs to be parsed differently:\r\n    // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\r\n    //    exp, but make sure to pad with spaces for consistent ranges\r\n    // 2. Expressions: wrap with parens (for e.g. object expressions)\r\n    // 3. Function arguments (v-for, v-slot): place in a function argument position\r\n    const source = asRawStatements\r\n        ? ` ${rawExp} `\r\n        : `(${rawExp})${asParams ? `=>{}` : ``}`;\r\n    try {\r\n        ast = parse(source, {\r\n            plugins: context.expressionPlugins\r\n        }).program;\r\n    }\r\n    catch (e) {\r\n        context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, e.message));\r\n        return node;\r\n    }\r\n    const ids = [];\r\n    const parentStack = [];\r\n    const knownIds = Object.create(context.identifiers);\r\n    walkIdentifiers(ast, (node, parent, _, isReferenced, isLocal) => {\r\n        if (isStaticPropertyKey(node, parent)) {\r\n            return;\r\n        }\r\n        // v2 wrapped filter call\r\n        if (__COMPAT__ && node.name.startsWith('_filter_')) {\r\n            return;\r\n        }\r\n        const needPrefix = isReferenced && canPrefix(node);\r\n        if (needPrefix && !isLocal) {\r\n            if (isStaticProperty(parent) && parent.shorthand) {\r\n                // property shorthand like { foo }, we need to add the key since\r\n                // we rewrite the value\r\n                ;\r\n                node.prefix = `${node.name}: `;\r\n            }\r\n            node.name = rewriteIdentifier(node.name, parent, node);\r\n            ids.push(node);\r\n        }\r\n        else {\r\n            // The identifier is considered constant unless it's pointing to a\r\n            // local scope variable (a v-for alias, or a v-slot prop)\r\n            if (!(needPrefix && isLocal) && !bailConstant) {\r\n                ;\r\n                node.isConstant = true;\r\n            }\r\n            // also generate sub-expressions for other identifiers for better\r\n            // source map support. (except for property keys which are static)\r\n            ids.push(node);\r\n        }\r\n    }, true, // invoke on ALL identifiers\r\n    parentStack, knownIds);\r\n    // We break up the compound expression into an array of strings and sub\r\n    // expressions (for identifiers that have been prefixed). In codegen, if\r\n    // an ExpressionNode has the `.children` property, it will be used instead of\r\n    // `.content`.\r\n    const children = [];\r\n    ids.sort((a, b) => a.start - b.start);\r\n    ids.forEach((id, i) => {\r\n        // range is offset by -1 due to the wrapping parens when parsed\r\n        const start = id.start - 1;\r\n        const end = id.end - 1;\r\n        const last = ids[i - 1];\r\n        const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);\r\n        if (leadingText.length || id.prefix) {\r\n            children.push(leadingText + (id.prefix || ``));\r\n        }\r\n        const source = rawExp.slice(start, end);\r\n        children.push(createSimpleExpression(id.name, false, {\r\n            source,\r\n            start: advancePositionWithClone(node.loc.start, source, start),\r\n            end: advancePositionWithClone(node.loc.start, source, end)\r\n        }, id.isConstant ? 3 /* CAN_STRINGIFY */ : 0 /* NOT_CONSTANT */));\r\n        if (i === ids.length - 1 && end < rawExp.length) {\r\n            children.push(rawExp.slice(end));\r\n        }\r\n    });\r\n    let ret;\r\n    if (children.length) {\r\n        ret = createCompoundExpression(children, node.loc);\r\n    }\r\n    else {\r\n        ret = node;\r\n        ret.constType = bailConstant\r\n            ? 0 /* NOT_CONSTANT */\r\n            : 3 /* CAN_STRINGIFY */;\r\n    }\r\n    ret.identifiers = Object.keys(knownIds);\r\n    return ret;\r\n}\r\nfunction canPrefix(id) {\r\n    // skip whitelisted globals\r\n    if (isGloballyWhitelisted(id.name)) {\r\n        return false;\r\n    }\r\n    // special case for webpack compilation\r\n    if (id.name === 'require') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction stringifyExpression(exp) {\r\n    if (isString(exp)) {\r\n        return exp;\r\n    }\r\n    else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        return exp.content;\r\n    }\r\n    else {\r\n        return exp.children\r\n            .map(stringifyExpression)\r\n            .join('');\r\n    }\r\n}\r\n//# sourceMappingURL=transformExpression.js.map","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/transform.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/ast.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/babelUtils.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/utils.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/errors.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/node_modules/.pnpm/@babel+types@7.15.6/node_modules/@babel/types/lib/index.d.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/validateExpression.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/node_modules/.pnpm/@babel+parser@7.15.8/node_modules/@babel/parser/typings/babel-parser.d.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/runtimeHelpers.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/compiler-core/src/options.ts"],"map":"{\"version\":3,\"file\":\"transformExpression.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../packages/compiler-core/src/transforms/transformExpression.ts\"],\"names\":[],\"mappings\":\"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\"}"}
