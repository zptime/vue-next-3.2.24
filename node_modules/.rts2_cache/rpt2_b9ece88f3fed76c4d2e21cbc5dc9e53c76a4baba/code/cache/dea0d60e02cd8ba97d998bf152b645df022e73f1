{"code":"import { walk } from 'estree-walker';\r\nexport function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {\r\n    if (__BROWSER__) {\r\n        return;\r\n    }\r\n    const rootExp = root.type === 'Program' &&\r\n        root.body[0].type === 'ExpressionStatement' &&\r\n        root.body[0].expression;\r\n    walk(root, {\r\n        enter(node, parent) {\r\n            parent && parentStack.push(parent);\r\n            if (parent &&\r\n                parent.type.startsWith('TS') &&\r\n                parent.type !== 'TSAsExpression' &&\r\n                parent.type !== 'TSNonNullExpression' &&\r\n                parent.type !== 'TSTypeAssertion') {\r\n                return this.skip();\r\n            }\r\n            if (node.type === 'Identifier') {\r\n                const isLocal = !!knownIds[node.name];\r\n                const isRefed = isReferencedIdentifier(node, parent, parentStack);\r\n                if (includeAll || (isRefed && !isLocal)) {\r\n                    onIdentifier(node, parent, parentStack, isRefed, isLocal);\r\n                }\r\n            }\r\n            else if (node.type === 'ObjectProperty' &&\r\n                parent.type === 'ObjectPattern') {\r\n                // mark property in destructure pattern\r\n                ;\r\n                node.inPattern = true;\r\n            }\r\n            else if (isFunctionType(node)) {\r\n                // walk function expressions and add its arguments to known identifiers\r\n                // so that we don't prefix them\r\n                walkFunctionParams(node, id => markScopeIdentifier(node, id, knownIds));\r\n            }\r\n            else if (node.type === 'BlockStatement') {\r\n                // #3445 record block-level local variables\r\n                walkBlockDeclarations(node, id => markScopeIdentifier(node, id, knownIds));\r\n            }\r\n        },\r\n        leave(node, parent) {\r\n            parent && parentStack.pop();\r\n            if (node !== rootExp && node.scopeIds) {\r\n                for (const id of node.scopeIds) {\r\n                    knownIds[id]--;\r\n                    if (knownIds[id] === 0) {\r\n                        delete knownIds[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\nexport function isReferencedIdentifier(id, parent, parentStack) {\r\n    if (__BROWSER__) {\r\n        return false;\r\n    }\r\n    if (!parent) {\r\n        return true;\r\n    }\r\n    // is a special keyword but parsed as identifier\r\n    if (id.name === 'arguments') {\r\n        return false;\r\n    }\r\n    if (isReferenced(id, parent)) {\r\n        return true;\r\n    }\r\n    // babel's isReferenced check returns false for ids being assigned to, so we\r\n    // need to cover those cases here\r\n    switch (parent.type) {\r\n        case 'AssignmentExpression':\r\n        case 'AssignmentPattern':\r\n            return true;\r\n        case 'ObjectPattern':\r\n        case 'ArrayPattern':\r\n            return isInDestructureAssignment(parent, parentStack);\r\n    }\r\n    return false;\r\n}\r\nexport function isInDestructureAssignment(parent, parentStack) {\r\n    if (parent &&\r\n        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {\r\n        let i = parentStack.length;\r\n        while (i--) {\r\n            const p = parentStack[i];\r\n            if (p.type === 'AssignmentExpression') {\r\n                return true;\r\n            }\r\n            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport function walkFunctionParams(node, onIdent) {\r\n    for (const p of node.params) {\r\n        for (const id of extractIdentifiers(p)) {\r\n            onIdent(id);\r\n        }\r\n    }\r\n}\r\nexport function walkBlockDeclarations(block, onIdent) {\r\n    for (const stmt of block.body) {\r\n        if (stmt.type === 'VariableDeclaration') {\r\n            if (stmt.declare)\r\n                continue;\r\n            for (const decl of stmt.declarations) {\r\n                for (const id of extractIdentifiers(decl.id)) {\r\n                    onIdent(id);\r\n                }\r\n            }\r\n        }\r\n        else if (stmt.type === 'FunctionDeclaration' ||\r\n            stmt.type === 'ClassDeclaration') {\r\n            if (stmt.declare || !stmt.id)\r\n                continue;\r\n            onIdent(stmt.id);\r\n        }\r\n    }\r\n}\r\nexport function extractIdentifiers(param, nodes = []) {\r\n    switch (param.type) {\r\n        case 'Identifier':\r\n            nodes.push(param);\r\n            break;\r\n        case 'MemberExpression':\r\n            let object = param;\r\n            while (object.type === 'MemberExpression') {\r\n                object = object.object;\r\n            }\r\n            nodes.push(object);\r\n            break;\r\n        case 'ObjectPattern':\r\n            for (const prop of param.properties) {\r\n                if (prop.type === 'RestElement') {\r\n                    extractIdentifiers(prop.argument, nodes);\r\n                }\r\n                else {\r\n                    extractIdentifiers(prop.value, nodes);\r\n                }\r\n            }\r\n            break;\r\n        case 'ArrayPattern':\r\n            param.elements.forEach(element => {\r\n                if (element)\r\n                    extractIdentifiers(element, nodes);\r\n            });\r\n            break;\r\n        case 'RestElement':\r\n            extractIdentifiers(param.argument, nodes);\r\n            break;\r\n        case 'AssignmentPattern':\r\n            extractIdentifiers(param.left, nodes);\r\n            break;\r\n    }\r\n    return nodes;\r\n}\r\nfunction markScopeIdentifier(node, child, knownIds) {\r\n    const { name } = child;\r\n    if (node.scopeIds && node.scopeIds.has(name)) {\r\n        return;\r\n    }\r\n    if (name in knownIds) {\r\n        knownIds[name]++;\r\n    }\r\n    else {\r\n        knownIds[name] = 1;\r\n    }\r\n    ;\r\n    (node.scopeIds || (node.scopeIds = new Set())).add(name);\r\n}\r\nexport const isFunctionType = (node) => {\r\n    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\r\n};\r\nexport const isStaticProperty = (node) => node &&\r\n    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\r\n    !node.computed;\r\nexport const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\r\n/**\r\n * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts\r\n * To avoid runtime dependency on @babel/types (which includes process references)\r\n * This file should not change very often in babel but we may need to keep it\r\n * up-to-date from time to time.\r\n *\r\n * https://github.com/babel/babel/blob/main/LICENSE\r\n *\r\n */\r\nfunction isReferenced(node, parent, grandparent) {\r\n    switch (parent.type) {\r\n        // yes: PARENT[NODE]\r\n        // yes: NODE.child\r\n        // no: parent.NODE\r\n        case 'MemberExpression':\r\n        case 'OptionalMemberExpression':\r\n            if (parent.property === node) {\r\n                return !!parent.computed;\r\n            }\r\n            return parent.object === node;\r\n        case 'JSXMemberExpression':\r\n            return parent.object === node;\r\n        // no: let NODE = init;\r\n        // yes: let id = NODE;\r\n        case 'VariableDeclarator':\r\n            return parent.init === node;\r\n        // yes: () => NODE\r\n        // no: (NODE) => {}\r\n        case 'ArrowFunctionExpression':\r\n            return parent.body === node;\r\n        // no: class { #NODE; }\r\n        // no: class { get #NODE() {} }\r\n        // no: class { #NODE() {} }\r\n        // no: class { fn() { return this.#NODE; } }\r\n        case 'PrivateName':\r\n            return false;\r\n        // no: class { NODE() {} }\r\n        // yes: class { [NODE]() {} }\r\n        // no: class { foo(NODE) {} }\r\n        case 'ClassMethod':\r\n        case 'ClassPrivateMethod':\r\n        case 'ObjectMethod':\r\n            if (parent.key === node) {\r\n                return !!parent.computed;\r\n            }\r\n            return false;\r\n        // yes: { [NODE]: \"\" }\r\n        // no: { NODE: \"\" }\r\n        // depends: { NODE }\r\n        // depends: { key: NODE }\r\n        case 'ObjectProperty':\r\n            if (parent.key === node) {\r\n                return !!parent.computed;\r\n            }\r\n            // parent.value === node\r\n            return !grandparent || grandparent.type !== 'ObjectPattern';\r\n        // no: class { NODE = value; }\r\n        // yes: class { [NODE] = value; }\r\n        // yes: class { key = NODE; }\r\n        case 'ClassProperty':\r\n            if (parent.key === node) {\r\n                return !!parent.computed;\r\n            }\r\n            return true;\r\n        case 'ClassPrivateProperty':\r\n            return parent.key !== node;\r\n        // no: class NODE {}\r\n        // yes: class Foo extends NODE {}\r\n        case 'ClassDeclaration':\r\n        case 'ClassExpression':\r\n            return parent.superClass === node;\r\n        // yes: left = NODE;\r\n        // no: NODE = right;\r\n        case 'AssignmentExpression':\r\n            return parent.right === node;\r\n        // no: [NODE = foo] = [];\r\n        // yes: [foo = NODE] = [];\r\n        case 'AssignmentPattern':\r\n            return parent.right === node;\r\n        // no: NODE: for (;;) {}\r\n        case 'LabeledStatement':\r\n            return false;\r\n        // no: try {} catch (NODE) {}\r\n        case 'CatchClause':\r\n            return false;\r\n        // no: function foo(...NODE) {}\r\n        case 'RestElement':\r\n            return false;\r\n        case 'BreakStatement':\r\n        case 'ContinueStatement':\r\n            return false;\r\n        // no: function NODE() {}\r\n        // no: function foo(NODE) {}\r\n        case 'FunctionDeclaration':\r\n        case 'FunctionExpression':\r\n            return false;\r\n        // no: export NODE from \"foo\";\r\n        // no: export * as NODE from \"foo\";\r\n        case 'ExportNamespaceSpecifier':\r\n        case 'ExportDefaultSpecifier':\r\n            return false;\r\n        // no: export { foo as NODE };\r\n        // yes: export { NODE as foo };\r\n        // no: export { NODE as foo } from \"foo\";\r\n        case 'ExportSpecifier':\r\n            // @ts-expect-error\r\n            if (grandparent === null || grandparent === void 0 ? void 0 : grandparent.source) {\r\n                return false;\r\n            }\r\n            return parent.local === node;\r\n        // no: import NODE from \"foo\";\r\n        // no: import * as NODE from \"foo\";\r\n        // no: import { NODE as foo } from \"foo\";\r\n        // no: import { foo as NODE } from \"foo\";\r\n        // no: import NODE from \"bar\";\r\n        case 'ImportDefaultSpecifier':\r\n        case 'ImportNamespaceSpecifier':\r\n        case 'ImportSpecifier':\r\n            return false;\r\n        // no: import \"foo\" assert { NODE: \"json\" }\r\n        case 'ImportAttribute':\r\n            return false;\r\n        // no: <div NODE=\"foo\" />\r\n        case 'JSXAttribute':\r\n            return false;\r\n        // no: [NODE] = [];\r\n        // no: ({ NODE }) = [];\r\n        case 'ObjectPattern':\r\n        case 'ArrayPattern':\r\n            return false;\r\n        // no: new.NODE\r\n        // no: NODE.target\r\n        case 'MetaProperty':\r\n            return false;\r\n        // yes: type X = { somePropert: NODE }\r\n        // no: type X = { NODE: OtherType }\r\n        case 'ObjectTypeProperty':\r\n            return parent.key !== node;\r\n        // yes: enum X { Foo = NODE }\r\n        // no: enum X { NODE }\r\n        case 'TSEnumMember':\r\n            return parent.id !== node;\r\n        // yes: { [NODE]: value }\r\n        // no: { NODE: value }\r\n        case 'TSPropertySignature':\r\n            if (parent.key === node) {\r\n                return !!parent.computed;\r\n            }\r\n            return true;\r\n    }\r\n    return true;\r\n}\r\n//# sourceMappingURL=babelUtils.js.map","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/node_modules/.pnpm/@babel+types@7.15.6/node_modules/@babel/types/lib/index.d.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/types/index.d.ts"],"map":"{\"version\":3,\"file\":\"babelUtils.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/compiler-core/src/babelUtils.ts\"],\"names\":[],\"mappings\":\"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\"}"}
