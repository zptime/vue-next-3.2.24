{"code":"import { Text, Fragment, Comment, cloneIfMounted, normalizeVNode, createVNode, isSameVNodeType, Static } from './vnode';\r\nimport { createComponentInstance, getExposeProxy, setupComponent } from './component';\r\nimport { filterSingleRoot, renderComponentRoot, shouldUpdateComponent, updateHOCHostEl } from './componentRenderUtils';\r\nimport { isString, EMPTY_OBJ, EMPTY_ARR, isReservedProp, isFunction, NOOP, hasOwn, invokeArrayFns, isArray, getGlobalThis } from '@vue/shared';\r\nimport { queueJob, queuePostFlushCb, flushPostFlushCbs, invalidateJob, flushPreFlushCbs } from './scheduler';\r\nimport { isRef, pauseTracking, resetTracking, ReactiveEffect } from '@vue/reactivity';\r\nimport { updateProps } from './componentProps';\r\nimport { updateSlots } from './componentSlots';\r\nimport { pushWarningContext, popWarningContext, warn } from './warning';\r\nimport { createAppAPI } from './apiCreateApp';\r\nimport { queueEffectWithSuspense } from './components/Suspense';\r\nimport { isKeepAlive } from './components/KeepAlive';\r\nimport { registerHMR, unregisterHMR, isHmrUpdating } from './hmr';\r\nimport { callWithErrorHandling, callWithAsyncErrorHandling } from './errorHandling';\r\nimport { createHydrationFunctions } from './hydration';\r\nimport { invokeDirectiveHook } from './directives';\r\nimport { startMeasure, endMeasure } from './profiling';\r\nimport { devtoolsComponentAdded, devtoolsComponentRemoved, devtoolsComponentUpdated, setDevtoolsHook } from './devtools';\r\nimport { initFeatureFlags } from './featureFlags';\r\nimport { isAsyncWrapper } from './apiAsyncComponent';\r\nimport { isCompatEnabled } from './compat/compatConfig';\r\nimport { registerLegacyRef } from './compat/ref';\r\nexport const queuePostRenderEffect = __FEATURE_SUSPENSE__\r\n    ? queueEffectWithSuspense\r\n    : queuePostFlushCb;\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nexport function createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nexport function createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    // compile-time feature flags check\r\n    if (__ESM_BUNDLER__ && !__TEST__) {\r\n        initFeatureFlags();\r\n    }\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\r\n    }\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = __DEV__ && isHmrUpdating ? false : !!n2.dynamicChildren) => {\r\n        if (n1 === n2) {\r\n            return;\r\n        }\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                else if (__DEV__) {\r\n                    patchStaticNode(n1, n2, container, isSVG);\r\n                }\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    ;\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if (__FEATURE_SUSPENSE__ && shapeFlag & 128 /* SUSPENSE */) {\r\n                    ;\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if (__DEV__) {\r\n                    warn('Invalid VNode type:', type, `(${typeof type})`);\r\n                }\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n        }\r\n        else {\r\n            // there's no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        // static nodes are only present when used with compiler-dom/runtime-dom\r\n        // which guarantees presence of hostInsertStaticContent.\r\n        ;\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const patchStaticNode = (n1, n2, container, isSVG) => {\r\n        // static nodes are only patched during dev for HMR\r\n        if (n2.children !== n1.children) {\r\n            const anchor = hostNextSibling(n1.anchor);\r\n            // remove existing\r\n            removeStaticNode(n1);\r\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n        }\r\n        else {\r\n            n2.el = n1.el;\r\n            n2.anchor = n1.anchor;\r\n        }\r\n    };\r\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostInsert(el, container, nextSibling);\r\n            el = next;\r\n        }\r\n        hostInsert(anchor, container, nextSibling);\r\n    };\r\n    const removeStaticNode = ({ el, anchor }) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostRemove(el);\r\n            el = next;\r\n        }\r\n        hostRemove(anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        isSVG = isSVG || n2.type === 'svg';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;\r\n        if (!__DEV__ &&\r\n            vnode.el &&\r\n            hostCloneNode !== undefined &&\r\n            patchFlag === -1 /* HOISTED */) {\r\n            // If a vnode has non-null el, it means it's being reused.\r\n            // Only static vnodes can be reused, so its mounted DOM nodes should be\r\n            // exactly the same, and we can simply do a clone here.\r\n            // only do this in production since cloned trees cannot be HMR updated.\r\n            el = vnode.el = hostCloneNode(vnode.el);\r\n        }\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (key !== 'value' && !isReservedProp(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                /**\r\n                 * Special case for setting value on DOM elements:\r\n                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\r\n                 * - it needs to be forced (#1471)\r\n                 * #2353 proposes adding another renderer option to configure this, but\r\n                 * the properties affects are so finite it is worth special casing it\r\n                 * here to reduce the complexity. (Special casing it also should not\r\n                 * affect non-DOM renderers)\r\n                 */\r\n                if ('value' in props) {\r\n                    hostPatchProp(el, 'value', null, props.value);\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\r\n        }\r\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n            Object.defineProperty(el, '__vnode', {\r\n                value: vnode,\r\n                enumerable: false\r\n            });\r\n            Object.defineProperty(el, '__vueParentComponent', {\r\n                value: parentComponent,\r\n                enumerable: false\r\n            });\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (slotScopeIds) {\r\n            for (let i = 0; i < slotScopeIds.length; i++) {\r\n                hostSetScopeId(el, slotScopeIds[i]);\r\n            }\r\n        }\r\n        if (parentComponent) {\r\n            let subTree = parentComponent.subTree;\r\n            if (__DEV__ &&\r\n                subTree.patchFlag > 0 &&\r\n                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {\r\n                subTree =\r\n                    filterSingleRoot(subTree.children) || subTree;\r\n            }\r\n            if (vnode === subTree) {\r\n                const parentVNode = parentComponent.vnode;\r\n                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode's patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || EMPTY_OBJ;\r\n        const newProps = n2.props || EMPTY_OBJ;\r\n        let vnodeHook;\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\r\n        }\r\n        if (__DEV__ && isHmrUpdating) {\r\n            // HMR updated, force full diff\r\n            patchFlag = 0;\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\r\n            if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {\r\n                traverseStaticChildren(n1, n2);\r\n            }\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\r\n        }\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element's render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, 'class', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        // #1471 force patch value\r\n                        if (next !== prev || key === 'value') {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // oldVNode may be an errored async setup() component inside Suspense\r\n            // which will not have a mounted element\r\n            oldVNode.el &&\r\n                // - In the case of a Fragment, we need to provide the actual parent\r\n                // of the Fragment itself so it can move its children.\r\n                (oldVNode.type === Fragment ||\r\n                    // - In the case of different nodes, there is going to be a replacement\r\n                    // which also requires the correct parent container\r\n                    !isSameVNodeType(oldVNode, newVNode) ||\r\n                    // - In the case of a component, it could contain anything.\r\n                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                // empty string is not valid prop\r\n                if (isReservedProp(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                // defer patching value\r\n                if (next !== prev && key !== 'value') {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== EMPTY_OBJ) {\r\n                for (const key in oldProps) {\r\n                    if (!isReservedProp(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n            if ('value' in newProps) {\r\n                hostPatchProp(el, 'value', oldProps.value, newProps.value);\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\r\n        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\r\n        if (__DEV__ && isHmrUpdating) {\r\n            // HMR updated, force full diff\r\n            patchFlag = 0;\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        // check if this is a slot fragment with :slotted scope ids\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren &&\r\n                // #2715 the previous fragment could've been a BAILed one as a result\r\n                // of renderSlot() with no valid children\r\n                n1.dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn't need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {\r\n                    traverseStaticChildren(n1, n2);\r\n                }\r\n                else if (\r\n                // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it's a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        n2.slotScopeIds = slotScopeIds;\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                ;\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        // 2.x compat may pre-create the component instance before actually\r\n        // mounting\r\n        const compatMountInstance = __COMPAT__ && initialVNode.isCompatRoot && initialVNode.component;\r\n        const instance = compatMountInstance ||\r\n            (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        if (__DEV__ && instance.type.__hmrId) {\r\n            registerHMR(instance);\r\n        }\r\n        if (__DEV__) {\r\n            pushWarningContext(initialVNode);\r\n            startMeasure(instance, `mount`);\r\n        }\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            ;\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        // resolve props and slots for setup context\r\n        if (!(__COMPAT__ && compatMountInstance)) {\r\n            if (__DEV__) {\r\n                startMeasure(instance, `init`);\r\n            }\r\n            setupComponent(instance);\r\n            if (__DEV__) {\r\n                endMeasure(instance, `init`);\r\n            }\r\n        }\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (__FEATURE_SUSPENSE__ && instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n        if (__DEV__) {\r\n            popWarningContext();\r\n            endMeasure(instance, `mount`);\r\n        }\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (__FEATURE_SUSPENSE__ &&\r\n                instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                // async & still pending - just update props and slots\r\n                // since the component's reactive effect for render isn't set-up yet\r\n                if (__DEV__) {\r\n                    pushWarningContext(n2);\r\n                }\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                if (__DEV__) {\r\n                    popWarningContext();\r\n                }\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.component = n1.component;\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        const componentUpdateFn = () => {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\r\n                effect.allowRecurse = false;\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    invokeArrayFns(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if (!isAsyncWrapperVNode &&\r\n                    (vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                if (__COMPAT__ &&\r\n                    isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n                    instance.emit('hook:beforeMount');\r\n                }\r\n                effect.allowRecurse = true;\r\n                if (el && hydrateNode) {\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    const hydrateSubTree = () => {\r\n                        if (__DEV__) {\r\n                            startMeasure(instance, `render`);\r\n                        }\r\n                        instance.subTree = renderComponentRoot(instance);\r\n                        if (__DEV__) {\r\n                            endMeasure(instance, `render`);\r\n                        }\r\n                        if (__DEV__) {\r\n                            startMeasure(instance, `hydrate`);\r\n                        }\r\n                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);\r\n                        if (__DEV__) {\r\n                            endMeasure(instance, `hydrate`);\r\n                        }\r\n                    };\r\n                    if (isAsyncWrapperVNode) {\r\n                        ;\r\n                        initialVNode.type.__asyncLoader().then(\r\n                        // note: we are moving the render call into an async callback,\r\n                        // which means it won't track dependencies - but it's ok because\r\n                        // a server-rendered async wrapper is already in resolved state\r\n                        // and it will never need to change.\r\n                        () => !instance.isUnmounted && hydrateSubTree());\r\n                    }\r\n                    else {\r\n                        hydrateSubTree();\r\n                    }\r\n                }\r\n                else {\r\n                    if (__DEV__) {\r\n                        startMeasure(instance, `render`);\r\n                    }\r\n                    const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                    if (__DEV__) {\r\n                        endMeasure(instance, `render`);\r\n                    }\r\n                    if (__DEV__) {\r\n                        startMeasure(instance, `patch`);\r\n                    }\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    if (__DEV__) {\r\n                        endMeasure(instance, `patch`);\r\n                    }\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if (!isAsyncWrapperVNode &&\r\n                    (vnodeHook = props && props.onVnodeMounted)) {\r\n                    const scopedInitialVNode = initialVNode;\r\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\r\n                }\r\n                if (__COMPAT__ &&\r\n                    isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n                    queuePostRenderEffect(() => instance.emit('hook:mounted'), parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);\r\n                    if (__COMPAT__ &&\r\n                        isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n                        queuePostRenderEffect(() => instance.emit('hook:activated'), parentSuspense);\r\n                    }\r\n                }\r\n                instance.isMounted = true;\r\n                if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentAdded(instance);\r\n                }\r\n                // #2458: deference mount-only object parameters to prevent memleaks\r\n                initialVNode = container = anchor = null;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component's own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if (__DEV__) {\r\n                    pushWarningContext(next || instance.vnode);\r\n                }\r\n                // Disallow component effect recursion during pre-lifecycle hooks.\r\n                effect.allowRecurse = false;\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    invokeArrayFns(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                if (__COMPAT__ &&\r\n                    isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n                    instance.emit('hook:beforeUpdate');\r\n                }\r\n                effect.allowRecurse = true;\r\n                // render\r\n                if (__DEV__) {\r\n                    startMeasure(instance, `render`);\r\n                }\r\n                const nextTree = renderComponentRoot(instance);\r\n                if (__DEV__) {\r\n                    endMeasure(instance, `render`);\r\n                }\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                if (__DEV__) {\r\n                    startMeasure(instance, `patch`);\r\n                }\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it's in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it's in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                if (__DEV__) {\r\n                    endMeasure(instance, `patch`);\r\n                }\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                    // to child component's vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\r\n                }\r\n                if (__COMPAT__ &&\r\n                    isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n                    queuePostRenderEffect(() => instance.emit('hook:updated'), parentSuspense);\r\n                }\r\n                if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentUpdated(instance);\r\n                }\r\n                if (__DEV__) {\r\n                    popWarningContext();\r\n                }\r\n            }\r\n        };\r\n        // create reactive effect for rendering\r\n        const effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope // track it in component's effect scope\r\n        );\r\n        const update = (instance.update = effect.run.bind(effect));\r\n        update.id = instance.uid;\r\n        // allowRecurse\r\n        // #1801, #2043 component render effects should allow recursive updates\r\n        effect.allowRecurse = update.allowRecurse = true;\r\n        if (__DEV__) {\r\n            effect.onTrack = instance.rtc\r\n                ? e => invokeArrayFns(instance.rtc, e)\r\n                : void 0;\r\n            effect.onTrigger = instance.rtg\r\n                ? e => invokeArrayFns(instance.rtg, e)\r\n                : void 0;\r\n            // @ts-ignore (for scheduler)\r\n            update.ownerInstance = instance;\r\n        }\r\n        update();\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children, optimized);\r\n        pauseTracking();\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n        resetTracking();\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, '');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        c1 = c1 || EMPTY_ARR;\r\n        c2 = c2 || EMPTY_ARR;\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {\r\n                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\r\n                    }\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : EMPTY_ARR;\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (__FEATURE_SUSPENSE__ && shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            ;\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode, true);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            ;\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\r\n        let vnodeHook;\r\n        if (shouldInvokeVnodeHook &&\r\n            (vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if (__FEATURE_SUSPENSE__ && shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\r\n            }\r\n            if (shapeFlag & 64 /* TELEPORT */) {\r\n                ;\r\n                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\r\n            }\r\n            else if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if ((type === Fragment &&\r\n                patchFlag &\r\n                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||\r\n                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((shouldInvokeVnodeHook &&\r\n            (vnodeHook = props && props.onVnodeUnmounted)) ||\r\n            shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === Fragment) {\r\n            removeFragment(el, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        if (__DEV__ && instance.type.__hmrId) {\r\n            unregisterHMR(instance);\r\n        }\r\n        const { bum, scope, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            invokeArrayFns(bum);\r\n        }\r\n        if (__COMPAT__ &&\r\n            isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n            instance.emit('hook:beforeDestroy');\r\n        }\r\n        // stop effects in component scope\r\n        scope.stop();\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            // so that scheduler will no longer invoke it\r\n            update.active = false;\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        if (__COMPAT__ &&\r\n            isCompatEnabled(\"INSTANCE_EVENT_HOOKS\" /* INSTANCE_EVENT_HOOKS */, instance)) {\r\n            queuePostRenderEffect(() => instance.emit('hook:destroyed'), parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (__FEATURE_SUSPENSE__ &&\r\n            parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n            devtoolsComponentRemoved(instance);\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container, isSVG) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container, null, null, null, isSVG);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        ;\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nexport function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\r\n    if (isArray(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\r\n        return;\r\n    }\r\n    if (isAsyncWrapper(vnode) && !isUnmount) {\r\n        // when mounting async components, nothing needs to be done,\r\n        // because the template ref is forwarded to inner component\r\n        return;\r\n    }\r\n    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */\r\n        ? getExposeProxy(vnode.component) || vnode.component.proxy\r\n        : vnode.el;\r\n    const value = isUnmount ? null : refValue;\r\n    const { i: owner, r: ref } = rawRef;\r\n    if (__DEV__ && !owner) {\r\n        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\r\n            `A vnode with ref must be created inside the render function.`);\r\n        return;\r\n    }\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // dynamic ref changed. unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if (isString(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if (hasOwn(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if (isRef(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if (isString(ref)) {\r\n        const doSet = () => {\r\n            if (__COMPAT__ && isCompatEnabled(\"V_FOR_REF\" /* V_FOR_REF */, owner)) {\r\n                registerLegacyRef(refs, ref, refValue, owner, rawRef.f, isUnmount);\r\n            }\r\n            else {\r\n                refs[ref] = value;\r\n            }\r\n            if (hasOwn(setupState, ref)) {\r\n                setupState[ref] = value;\r\n            }\r\n        };\r\n        // #1789: for non-null values, set them after render\r\n        // null values means this is unmount and it should not overwrite another\r\n        // ref with the same key\r\n        if (value) {\r\n            ;\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (isRef(ref)) {\r\n        const doSet = () => {\r\n            ref.value = value;\r\n        };\r\n        if (value) {\r\n            ;\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (isFunction(ref)) {\r\n        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n    }\r\n    else if (__DEV__) {\r\n        warn('Invalid template ref type:', value, `(${typeof value})`);\r\n    }\r\n}\r\nexport function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always be moved. Therefore, in order to ensure correct move\r\n * position, el should be inherited from previous nodes.\r\n */\r\nexport function traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if (isArray(ch1) && isArray(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n            // would have received .el during block patch)\r\n            if (__DEV__ && c2.type === Comment && !c2.el) {\r\n                c2.el = c1.el;\r\n            }\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = (u + v) >> 1;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=renderer.js.map","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/vnode.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/component.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/componentRenderUtils.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/scheduler.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/reactivity/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/componentProps.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/componentSlots.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/warning.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/apiCreateApp.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/components/Suspense.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/components/Teleport.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/components/KeepAlive.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/hmr.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/errorHandling.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/hydration.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/directives.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/profiling.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/devtools.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/featureFlags.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/apiAsyncComponent.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/compat/compatConfig.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/compat/compatConfig.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/compat/ref.ts"],"map":"{\"version\":3,\"file\":\"renderer.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/runtime-core/src/renderer.ts\"],\"names\":[],\"mappings\":\"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\"}"}
