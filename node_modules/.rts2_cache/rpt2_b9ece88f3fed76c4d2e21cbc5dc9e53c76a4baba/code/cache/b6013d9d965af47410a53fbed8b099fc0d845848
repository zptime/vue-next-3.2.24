{"code":"import { callWithErrorHandling } from './errorHandling';\r\nimport { isArray, NOOP } from '@vue/shared';\r\nimport { getComponentName } from './component';\r\nimport { warn } from './warning';\r\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nexport function nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(id) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < id ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nexport function queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        if (job.id == null) {\r\n            queue.push(job);\r\n        }\r\n        else {\r\n            queue.splice(findInsertionIndex(job.id), 0, job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nexport function invalidateJob(job) {\r\n    const i = queue.indexOf(job);\r\n    if (i > flushIndex) {\r\n        queue.splice(i, 1);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nexport function queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nexport function queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nexport function flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if (__DEV__) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if (__DEV__ &&\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {\r\n                continue;\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nexport function flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if (__DEV__) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if (__DEV__ &&\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\r\n                continue;\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if (__DEV__) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    // conditional usage of checkRecursiveUpdate must be determined out of\r\n    // try ... catch block since Rollup by default de-optimizes treeshaking\r\n    // inside try-catch. This can leave all warning code unshaked. Although\r\n    // they would get eventually shaken by a minifier like terser, some minifiers\r\n    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n    const check = __DEV__\r\n        ? (job) => checkRecursiveUpdates(seen, job)\r\n        : NOOP;\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job && job.active !== false) {\r\n                if (__DEV__ && check(job)) {\r\n                    continue;\r\n                }\r\n                // console.log(`running:`, job.id)\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length ||\r\n            pendingPreFlushCbs.length ||\r\n            pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            const instance = fn.ownerInstance;\r\n            const componentName = instance && getComponentName(instance.type);\r\n            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n            return true;\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=scheduler.js.map","references":["/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/errorHandling.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/shared/src/index.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/component.ts","/Users/zhangpian/Documents/projects/github/vue-next-3.2.24/packages/runtime-core/src/warning.ts"],"map":"{\"version\":3,\"file\":\"scheduler.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/runtime-core/src/scheduler.ts\"],\"names\":[],\"mappings\":\"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\"}"}
